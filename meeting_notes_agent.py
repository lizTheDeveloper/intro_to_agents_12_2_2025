from openai import OpenAI
import json
import os
from datetime import datetime
from pathlib import Path
import logging
import sys

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Check for OpenAI API key
if not os.getenv("OPENAI_API_KEY"):
    logger.error("OPENAI_API_KEY environment variable is not set!")
    logger.error("Please set it with: export OPENAI_API_KEY='your-api-key-here'")
    print("\n" + "=" * 70)
    print("ERROR: OpenAI API Key Not Found")
    print("=" * 70)
    print("\nThe OPENAI_API_KEY environment variable is required.")
    print("\nTo set it, run:")
    print("  export OPENAI_API_KEY='your-api-key-here'")
    print("\nOr add it to your shell profile (~/.zshrc or ~/.bashrc):")
    print("  echo 'export OPENAI_API_KEY=\"your-api-key-here\"' >> ~/.zshrc")
    print("\n" + "=" * 70 + "\n")
    
    # Only exit if not being imported
    if __name__ == "__main__":
        sys.exit(1)

try:
    client = OpenAI()
except Exception as error:
    logger.error(f"Failed to initialize OpenAI client: {error}")
    if __name__ == "__main__":
        sys.exit(1)
    raise

# Constants
MEETING_NOTES_DIR = Path(__file__).parent / "meeting_notes"
MEETING_NOTES_DIR.mkdir(exist_ok=True)


def transcribe_audio(audio_file_path):
    """Transcribe an audio file using OpenAI Whisper API."""
    logger.info(f"Transcribing audio file: {audio_file_path}")
    
    try:
        with open(audio_file_path, "rb") as audio_file:
            transcript = client.audio.transcriptions.create(
                model="whisper-1",
                file=audio_file,
                response_format="text"
            )
        logger.info("Transcription completed successfully")
        return transcript
    except Exception as error:
        logger.error(f"Error transcribing audio: {error}")
        return f"Error: {str(error)}"


def save_meeting_notes(meeting_name, date, attendees, summary, transcript, todos):
    """Save meeting notes to a Markdown file."""
    logger.info(f"Saving meeting notes for: {meeting_name}")
    
    # Create filename with ISO date format
    safe_meeting_name = meeting_name.replace(" ", "_").replace("/", "-")
    filename = f"{date}_{safe_meeting_name}.md"
    filepath = MEETING_NOTES_DIR / filename
    
    # Format attendees list
    attendees_list = "\n".join([f"- {attendee}" for attendee in attendees])
    
    # Format todos with GitHub checkboxes
    todos_list = "\n".join([f"- [ ] {todo}" for todo in todos])
    
    # Create Markdown content
    content = f"""# {meeting_name}

**Date:** {date}
**Time:** {datetime.now().strftime("%H:%M")}

## Attendees
{attendees_list}

## Summary
{summary}

## Action Items
{todos_list}

## Full Transcript
```
{transcript}
```

---
*Notes generated by Meeting Notes Agent*
"""
    
    # Write to file
    with open(filepath, "w") as file:
        file.write(content)
    
    logger.info(f"Meeting notes saved to: {filepath}")
    return str(filepath)


def list_all_todos():
    """List all pending to-dos from all meeting notes."""
    logger.info("Listing all pending to-dos")
    
    all_todos = []
    
    for notes_file in MEETING_NOTES_DIR.glob("*.md"):
        with open(notes_file, "r") as file:
            content = file.read()
            
        # Extract meeting name from first line
        lines = content.split("\n")
        meeting_name = lines[0].replace("# ", "").strip() if lines else notes_file.stem
        
        # Find unchecked to-dos
        in_action_items = False
        for line in lines:
            if line.strip() == "## Action Items":
                in_action_items = True
                continue
            if in_action_items:
                if line.startswith("##"):
                    break
                if line.strip().startswith("- [ ]"):
                    todo_text = line.replace("- [ ]", "").strip()
                    all_todos.append({
                        "meeting": meeting_name,
                        "file": notes_file.name,
                        "todo": todo_text
                    })
    
    return all_todos


def update_todo_status(filename, todo_text, completed=True):
    """Update the status of a to-do item in a meeting notes file."""
    logger.info(f"Updating to-do status in {filename}")
    
    filepath = MEETING_NOTES_DIR / filename
    
    if not filepath.exists():
        return f"Error: File {filename} not found"
    
    with open(filepath, "r") as file:
        content = file.read()
    
    # Replace the to-do checkbox
    checkbox_old = "- [ ]"
    checkbox_new = "- [x]" if completed else "- [ ]"
    
    # Find and replace the specific to-do
    lines = content.split("\n")
    updated_lines = []
    for line in lines:
        if todo_text in line and checkbox_old in line:
            line = line.replace(checkbox_old, checkbox_new)
        updated_lines.append(line)
    
    updated_content = "\n".join(updated_lines)
    
    with open(filepath, "w") as file:
        file.write(updated_content)
    
    logger.info(f"To-do status updated: {todo_text}")
    return f"Updated: {todo_text}"


class MeetingNotesAgent:
    def __init__(self):
        self.tools = [
            {
                "type": "function",
                "function": {
                    "name": "transcribe_audio",
                    "description": "Transcribe an audio file of a meeting to text using OpenAI Whisper. Returns the full transcript.",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "audio_file_path": {
                                "type": "string",
                                "description": "Path to the audio file (mp3, wav, m4a, etc.)",
                            },
                        },
                        "required": ["audio_file_path"],
                    },
                }
            },
            {
                "type": "function",
                "function": {
                    "name": "save_meeting_notes",
                    "description": "Save structured meeting notes to a Markdown file with action items formatted as GitHub checkboxes.",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "meeting_name": {
                                "type": "string",
                                "description": "Name or title of the meeting",
                            },
                            "date": {
                                "type": "string",
                                "description": "Date of the meeting in YYYY-MM-DD format",
                            },
                            "attendees": {
                                "type": "array",
                                "items": {"type": "string"},
                                "description": "List of meeting attendees",
                            },
                            "summary": {
                                "type": "string",
                                "description": "Brief summary of the meeting",
                            },
                            "transcript": {
                                "type": "string",
                                "description": "Full transcript of the meeting",
                            },
                            "todos": {
                                "type": "array",
                                "items": {"type": "string"},
                                "description": "List of action items/to-dos from the meeting",
                            },
                        },
                        "required": ["meeting_name", "date", "attendees", "summary", "transcript", "todos"],
                    },
                }
            },
            {
                "type": "function",
                "function": {
                    "name": "list_all_todos",
                    "description": "List all pending to-do items from all meeting notes files.",
                    "parameters": {
                        "type": "object",
                        "properties": {},
                    },
                }
            },
            {
                "type": "function",
                "function": {
                    "name": "update_todo_status",
                    "description": "Mark a to-do item as completed (or uncompleted) in a meeting notes file.",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "filename": {
                                "type": "string",
                                "description": "Name of the meeting notes file (e.g., 2024-12-03_team_sync.md)",
                            },
                            "todo_text": {
                                "type": "string",
                                "description": "The text of the to-do item to update",
                            },
                            "completed": {
                                "type": "boolean",
                                "description": "True to mark as completed, False to mark as pending",
                            },
                        },
                        "required": ["filename", "todo_text", "completed"],
                    },
                }
            },
        ]
        
        self.name = "MeetingNotesAgent"
        self.system_prompt = f"""You are an expert meeting notes assistant. Your role is to:

1. Transcribe audio recordings of meetings
2. Extract key information including:
   - Meeting attendees
   - Main discussion topics
   - Decisions made
   - Action items and to-do items (with assignees and due dates when mentioned)
3. Create well-structured meeting notes in Markdown format
4. Track and manage action items across meetings

When processing a meeting:
- Use the transcribe_audio function to get the transcript
- Carefully analyze the transcript to identify all action items and to-dos
- Extract attendee names when mentioned
- Note any deadlines or assignees for to-dos
- Create a clear summary of key points
- Save everything in a structured Markdown format with GitHub-style checkboxes for to-dos

When asked about to-dos:
- Use list_all_todos to see pending items across all meetings
- Use update_todo_status to mark items as complete

Always be thorough and accurate in capturing meeting details."""
        
        self.conversation_history = [
            {"role": "system", "content": self.system_prompt}
        ]
    
    def execute_tool(self, tool_name, arguments):
        """Execute a tool function and return the result."""
        logger.info(f"Executing tool: {tool_name}")
        
        if tool_name == "transcribe_audio":
            return transcribe_audio(arguments["audio_file_path"])
        elif tool_name == "save_meeting_notes":
            return save_meeting_notes(
                arguments["meeting_name"],
                arguments["date"],
                arguments["attendees"],
                arguments["summary"],
                arguments["transcript"],
                arguments["todos"]
            )
        elif tool_name == "list_all_todos":
            return list_all_todos()
        elif tool_name == "update_todo_status":
            return update_todo_status(
                arguments["filename"],
                arguments["todo_text"],
                arguments.get("completed", True)
            )
        else:
            return f"Error: Unknown tool {tool_name}"
    
    def chat(self, user_message):
        """Send a message and handle the agent's response with tool calls."""
        logger.info(f"User message: {user_message}")
        
        self.conversation_history.append({
            "role": "user",
            "content": user_message
        })
        
        while True:
            response = client.chat.completions.create(
                model="gpt-4o",
                messages=self.conversation_history,
                tools=self.tools,
                tool_choice="auto"
            )
            
            message = response.choices[0].message
            
            # Add assistant's response to history
            self.conversation_history.append(message)
            
            # Check if there are tool calls
            if message.tool_calls:
                logger.info(f"Agent requested {len(message.tool_calls)} tool call(s)")
                
                # Execute each tool call
                for tool_call in message.tool_calls:
                    function_name = tool_call.function.name
                    function_args = json.loads(tool_call.function.arguments)
                    
                    logger.info(f"Calling {function_name} with args: {function_args}")
                    
                    # Execute the tool
                    result = self.execute_tool(function_name, function_args)
                    
                    # Add the tool result to conversation history
                    self.conversation_history.append({
                        "role": "tool",
                        "tool_call_id": tool_call.id,
                        "name": function_name,
                        "content": json.dumps(result) if not isinstance(result, str) else result
                    })
                
                # Continue the loop to get the next response
                continue
            else:
                # No more tool calls, return the final response
                return message.content
    
    def process_meeting_audio(self, audio_file_path, meeting_name=None, date=None):
        """Convenience method to process a meeting audio file end-to-end."""
        if date is None:
            date = datetime.now().strftime("%Y-%m-%d")
        
        if meeting_name is None:
            meeting_name = f"Meeting on {date}"
        
        prompt = f"""Please process this meeting audio file:
- Audio file path: {audio_file_path}
- Meeting name: {meeting_name}
- Date: {date}

Transcribe the audio, extract all action items and to-dos, identify attendees if mentioned, 
create a summary, and save the meeting notes in Markdown format."""
        
        return self.chat(prompt)


def main():
    """Example usage of the Meeting Notes Agent."""
    agent = MeetingNotesAgent()
    
    print("=" * 60)
    print("Meeting Notes Agent")
    print("=" * 60)
    print()
    print("Commands:")
    print("  - Type a message to chat with the agent")
    print("  - 'process <audio_file_path>' to transcribe and process a meeting")
    print("  - 'todos' to list all pending to-dos")
    print("  - 'quit' to exit")
    print()
    
    while True:
        user_input = input("\nYou: ").strip()
        
        if not user_input:
            continue
        
        if user_input.lower() == "quit":
            print("Goodbye!")
            break
        
        if user_input.lower() == "todos":
            todos = list_all_todos()
            if todos:
                print("\nPending To-Dos:")
                for todo in todos:
                    print(f"  [{todo['meeting']}] {todo['todo']}")
            else:
                print("\nNo pending to-dos found.")
            continue
        
        if user_input.lower().startswith("process "):
            audio_path = user_input[8:].strip()
            print(f"\nProcessing meeting audio: {audio_path}")
            print("This may take a moment...")
            response = agent.process_meeting_audio(audio_path)
            print(f"\nAgent: {response}")
            continue
        
        # Regular chat
        response = agent.chat(user_input)
        print(f"\nAgent: {response}")


if __name__ == "__main__":
    main()

